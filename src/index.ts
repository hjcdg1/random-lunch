import { app, BrowserWindow, ipcMain, nativeTheme } from 'electron';
import * as FileSystem from './main/fileSystem';
import type { Assignment, Member } from './shared/types';
import { runSimulatedAnnealing } from './algorithm/simulatedAnnealing';
import { updateEdgeWeights } from './algorithm/edgeWeights';

// Daangn eHR API Integration
interface EHRProfile {
  id: number;
  name: string;
  original_name: string;
  department_code: string;
  employment_status: string;
  slack_user_id: string;
}

interface EHRDepartment {
  code: string;
  name: string;
  full_name: string;
}

async function getDaangnProfiles(token: string): Promise<EHRProfile[]> {
  const response = await fetch('https://ehr.karrotmarket.com/api/internal/profiles', {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch profiles: ${response.status} ${response.statusText}`);
  }

  return await response.json();
}

async function getDaangnDepartments(token: string): Promise<EHRDepartment[]> {
  const response = await fetch('https://ehr.karrotmarket.com/api/internal/departments', {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch departments: ${response.status} ${response.statusText}`);
  }

  return await response.json();
}

async function fetchMembersFromAPI(token: string, departmentName: string): Promise<Member[]> {
  if (!token || token.trim() === '') {
    throw new Error('API 토큰이 설정되지 않았습니다. 설정 페이지에서 토큰을 입력해주세요.');
  }

  if (!departmentName || departmentName.trim() === '') {
    throw new Error('부서명이 설정되지 않았습니다. 설정 페이지에서 부서명을 입력해주세요.');
  }

  // Fetch both profiles and departments in parallel
  const [profiles, departments] = await Promise.all([
    getDaangnProfiles(token),
    getDaangnDepartments(token),
  ]);

  // Filter departments by name (same logic as api-example.js)
  const filteredDepartments = departments.filter(dept => dept.full_name.includes(departmentName));

  // Create department map for filtered departments
  const departmentMap = new Map<string, EHRDepartment>();
  filteredDepartments.forEach(dept => {
    departmentMap.set(dept.code, dept);
  });

  const departmentCodes = new Set(filteredDepartments.map(d => d.code));

  // Filter profiles by department code and active status
  const members: Member[] = profiles
    .filter(profile => departmentCodes.has(profile.department_code))
    .filter(profile => profile.employment_status === 'active')
    .map(profile => ({
      id: profile.id,
      nickname: profile.name,
      realName: profile.original_name,
      department: departmentMap.get(profile.department_code)?.name || profile.department_code,
      slackUserId: profile.slack_user_id,
    }));

  return members;
}

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let mainWindow: BrowserWindow | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools only in development
  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// ============================================================================
// IPC Handlers
// ============================================================================

// Member operations
ipcMain.handle('fetch-members', async () => {
  console.log('Fetching members from Daangn eHR API...');

  try {
    // Load settings to get API token and department name
    const settings = await FileSystem.loadSettings();

    // Fetch members from API filtered by department
    const members = await fetchMembersFromAPI(settings.apiToken, settings.departmentName);

    console.log(
      `Successfully fetched ${members.length} active members from department: ${settings.departmentName}`
    );
    return members;
  } catch (error) {
    console.error('Failed to fetch members:', error);
    throw error;
  }
});

// Assignment operations
ipcMain.handle('load-assignments', async () => {
  return await FileSystem.loadAssignments();
});

ipcMain.handle('load-assignment', async (_event, timestamp: number) => {
  return await FileSystem.loadAssignment(timestamp);
});

ipcMain.handle('delete-assignment', async (_event, timestamp: number) => {
  await FileSystem.deleteAssignment(timestamp);
});

ipcMain.handle('create-assignment', async (_event, memberIds: number[]) => {
  console.log(`Creating assignment for ${memberIds.length} members...`);

  // Load current edge weights
  const currentWeights = await FileSystem.loadEdgeWeights();

  // Run Simulated Annealing to find optimal groups
  const result = runSimulatedAnnealing(memberIds, currentWeights);

  const timestamp = Date.now();
  const assignment: Assignment = {
    timestamp,
    groups: result.groups,
    participatingMembers: memberIds,
  };

  // Update edge weights based on the new assignment
  const { updated: updatedWeights, updates: edgeUpdates } = updateEdgeWeights(
    currentWeights,
    result.groups
  );

  // Save updated weights
  await FileSystem.saveEdgeWeights(updatedWeights);

  // Save assignment
  await FileSystem.saveAssignment(assignment, edgeUpdates);

  console.log(`Assignment created with cost ${result.cost}, ${result.groups.length} groups`);

  return assignment;
});

// Settings operations
ipcMain.handle('load-settings', async () => {
  return await FileSystem.loadSettings();
});

ipcMain.handle(
  'save-settings',
  async (_event, settings: Partial<import('./shared/types').Settings>) => {
    await FileSystem.updateSettings(settings);
  }
);

// Edge weights operations
ipcMain.handle('load-edge-weights', async () => {
  return await FileSystem.loadEdgeWeights();
});

ipcMain.handle(
  'save-edge-weights',
  async (_event, weights: import('./shared/types').EdgeWeightMap) => {
    await FileSystem.saveEdgeWeights(weights);
  }
);

// Theme operations
ipcMain.handle('get-system-theme', () => {
  return nativeTheme.shouldUseDarkColors ? 'dark' : 'light';
});

nativeTheme.on('updated', () => {
  const theme = nativeTheme.shouldUseDarkColors ? 'dark' : 'light';
  mainWindow?.webContents.send('system-theme-changed', theme);
});
